# [백준]9019번 : DSLR

- https://www.acmicpc.net/problem/9019
- 0~10000사이의 숫자 N의 각 자리수를 d1,d2,d3,d4라 할 때
  1. D: D 는 n을 두 배로 바꾼다. 결과 값이 9999 보다 큰 경우에는 10000 으로 나눈 나머지를 취한다. 그 결과 값(2n mod 10000)을 레지스터에 저장한다.
  2. S: S 는 n에서 1 을 뺀 결과 n-1을 레지스터에 저장한다. n이 0 이라면 9999 가 대신 레지스터에 저장된다.
  3. L: L 은 n의 각 자릿수를 왼편으로 회전시켜 그 결과를 레지스터에 저장한다. 이 연산이 끝나면 레지스터에 저장된 네 자릿수는 왼편부터 d2, d3, d4, d1이 된다.
  4. R: R 은 n의 각 자릿수를 오른편으로 회전시켜 그 결과를 레지스터에 저장한다. 이 연산이 끝나면 레지스터에 저장된 네 자릿수는 왼편부터 d4, d1, d2, d3이 된다.
- 숫자 A와 B를 주어졌을 때 A에서 B로 만드는 최소한의 명령어들을 출력하라.



- 전형적인 BFS문제였다. 여기서 조금 더 심화시킨다면 아마 변화한 값 모두 출력하라는 조건이 붙었을 것이다. 

- 여기서 핵심은 'L'과'R'연산을 어떻게 계산 최소화 시키냐는 것이다.

  - N = ((d1 × 10 + d2) × 10 + d3) × 10 + d4 나타낼 수 있다.

  1.  d1,d2,d3,d4 각각 따로 저장해서 회전시킨다. → 구현해본 결과 결국은 어떻게 구현해도 시간초과가 나옴, N을 여러번 계산해야하기 때문인듯

  2. 간단한 수학식으로 변환시켜서 구현한다.

     - 'L' 의 결과 = (N% 1000)＊10 + (N/ 1000); 로 나타낼 수 있다.

       - d1을 제외한 (d2-d3-d4)를 구해서 각자리수에 맞게 연산하고, d1을 더하면 된다.

     - 'R'의 결과 = (N% 10)＊1000 + (N/ 10); 로 나타낼 수 있다. 

       - (d1-d2-d3)를 구해서 각 자리수에 맞게 연산하고, d4를 맨앞에 붙이도록1000을 곱해서 더해준다.

     - 이런식으로 구현하면 기존에는 곱셈3번,덧셈3번으로 구하는데 (곱셈,나머지,나누기)연산3번,덧셈1번으로 구할 수 있다.